"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fse = require("fs-extra");
const uuidv4 = require("uuid/v4");
const vscode_extension_telemetry_1 = require("vscode-extension-telemetry");
const event_1 = require("./event");
let isDebug = false;
let reporter;
/**
 * Initialize TelemetryReporter by parsing attributes from a JSON file.
 * It reads these attributes: publisher, name, version, aiKey.
 * @param jsonFilepath absolute path of a JSON file.
 * @param debug If set as true, debug information be printed to console.
 */
function initializeFromJsonFile(jsonFilepath, debug) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(yield fse.pathExists(jsonFilepath))) {
            throw new Error(`The Json file '${jsonFilepath}' does not exist.`);
        }
        const { publisher, name, version, aiKey } = yield fse.readJSON(jsonFilepath);
        initialize(`${publisher}.${name}`, version, aiKey, !!debug);
    });
}
exports.initializeFromJsonFile = initializeFromJsonFile;
/**
 * Initialize TelemetryReporter from given attributes.
 * @param extensionId Identifier of the extension, used as prefix of EventName in telemetry data.
 * @param version Version of the extension.
 * @param aiKey Key of Application Insights.
 * @param debug If set as true, debug information be printed to console.
 */
function initialize(extensionId, version, aiKey, debug) {
    if (reporter) {
        throw new Error("TelemetryReporter already initilized.");
    }
    if (aiKey) {
        reporter = new vscode_extension_telemetry_1.default(extensionId, version, aiKey);
    }
    isDebug = !!debug;
}
exports.initialize = initialize;
/**
 * Mark an Error instance as a user error.
 */
function setUserError(err) {
    err.isUserError = true;
}
exports.setUserError = setUserError;
/**
 * Set custom error code or an Error instance.
 * @param errorCode A custom error code.
 */
function setErrorCode(err, errorCode) {
    err.errorCode = errorCode;
}
exports.setErrorCode = setErrorCode;
/**
 * Instrument callback for a command to auto send OPEARTION_START, OPERATION_END, ERROR telemetry.
 * @param operationName For extension activation, use "activation", for VS Code commands, use command name.
 * @param cb The callback function with a unique Id passed by its 1st parameter.
 * @returns The instrumented callback.
 */
function instrumentOperation(operationName, cb) {
    return (...args) => __awaiter(this, void 0, void 0, function* () {
        let error;
        const operationId = createUuid();
        const startAt = Date.now();
        try {
            sendOperationStart(operationId, operationName);
            return yield cb(operationId, ...args);
        }
        catch (e) {
            error = e;
            sendOperationError(operationId, operationName, e);
        }
        finally {
            const duration = Date.now() - startAt;
            sendOperationEnd(operationId, operationName, duration, error);
        }
    });
}
exports.instrumentOperation = instrumentOperation;
/**
 * Send OPERATION_START event.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 */
function sendOperationStart(operationId, operationName) {
    const event = {
        eventName: event_1.EventName.OPERATION_START,
        operationId,
        operationName,
    };
    sendEvent(event);
}
exports.sendOperationStart = sendOperationStart;
/**
 * Send OPERATION_END event.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 * @param duration Time elapsed for the operation, in milliseconds.
 * @param err An optional Error instance if occurs during the operation.
 */
function sendOperationEnd(operationId, operationName, duration, err) {
    const event = Object.assign({ eventName: event_1.EventName.OPERATION_END, operationId,
        operationName,
        duration }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendOperationEnd = sendOperationEnd;
/**
 * Send an ERROR event.
 * @param err An Error instance.
 */
function sendError(err) {
    const event = Object.assign({ eventName: event_1.EventName.ERROR }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendError = sendError;
/**
 * Send an ERROR event during an operation, carrying id and name of the oepration.
 * @param operationId Unique id of the operation.
 * @param operationName Name of the operation.
 * @param err An Error instance containing details.
 */
function sendOperationError(operationId, operationName, err) {
    const event = Object.assign({ eventName: event_1.EventName.ERROR, operationId,
        operationName }, extractErrorInfo(err));
    sendEvent(event);
}
exports.sendOperationError = sendOperationError;
/**
 * Create a UUID string using uuid.v4().
 */
function createUuid() {
    return uuidv4();
}
exports.createUuid = createUuid;
/**
 * Dispose the reporter.
 */
function dispose() {
    return __awaiter(this, void 0, void 0, function* () {
        if (reporter) {
            return yield reporter.dispose();
        }
    });
}
exports.dispose = dispose;
function extractErrorInfo(err) {
    if (!err) {
        return {
            errorCode: event_1.ErrorCodes.NO_ERROR,
        };
    }
    const richError = err;
    return {
        errorCode: richError.errorCode || event_1.ErrorCodes.GENERAL_ERROR,
        errorType: richError.isUserError ? event_1.ErrorType.USER_ERROR : event_1.ErrorType.SYSTEM_ERROR,
        message: err.message,
        stack: err.stack,
    };
}
function sendEvent(event) {
    if (!reporter) {
        return;
    }
    const dimensions = {};
    for (const key of event_1.DimensionEntries) {
        const value = event[key];
        if (value !== undefined) {
            dimensions[key] = String(value);
        }
    }
    const measurements = {};
    for (const key of event_1.MeasurementEntries) {
        const value = event[key];
        if (value !== undefined) {
            measurements[key] = value;
        }
    }
    reporter.sendTelemetryEvent(event.eventName, dimensions, measurements);
    if (isDebug) {
        // tslint:disable-next-line:no-console
        console.log(event.eventName, { eventName: event.eventName, dimensions, measurements });
    }
}
//# sourceMappingURL=index.js.map